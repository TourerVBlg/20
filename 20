#include <iostream>
#include <cstring>
#include <thread>
#include <vector>
#include <unordered_map>
#include <shared_mutex>
#include <boost/asio.hpp>
#include <boost/bind.hpp>
#include <boost/algorithm/string.hpp>
#include <openssl/sha.h>

#define MAX_BUFFER_SIZE 1024

using boost::asio::ip::tcp;

class Server {
public:
    Server() : acceptor_(io_context_, tcp::endpoint(tcp::v4(), 12345)) {}

    void start() {
        std::cout << "Server started. Listening on port 12345..." << std::endl;

        while (!stop_server_) {
            auto peer_socket = std::make_shared<tcp::socket>(io_context_);
            acceptor_.accept(*peer_socket);

            std::thread peer_thread([peer_socket, this]() {
                try {
                    char buffer[MAX_BUFFER_SIZE];
                    boost::system::error_code error;
                    size_t bytes_received = peer_socket->read_some(boost::asio::buffer(buffer), error);
            
                    if (!error) {
                        std::string message(buffer, bytes_received);
                        boost::algorithm::trim(message);

                        // Обработка приветственного сообщения
            
                        if (message == "HELLO") {
                            boost::asio::write(*peer_socket, boost::asio::buffer("CONNECTED", 9));
                            handle_peer(peer_socket, "");
                        }
                        else {
                            throw std::runtime_error("Invalid greeting received.");
                        }
                    }
                    else {
                        throw std::runtime_error("Error reading from socket: " + error.message());
                    }
                }
                catch (const std::exception& ex) {
                    std::cerr << "Exception in peer thread: " << ex.what() << std::endl;
                    handle_exception(peer_socket);
                }
            });
            peer_thread.detach();
        }

        io_context_.run();
    }

private:
    boost::asio::io_context io_context_;
    tcp::acceptor acceptor_;
    std::atomic<bool> stop_server_{ false };
    UserCredentialsManager user_credentials_manager_;

    void handle_peer(const std::shared_ptr<tcp::socket>& peer_socket, const std::string& username) {
        // Обработка соединения с клиентом
        // ...
    }

    void handle_exception(const std::shared_ptr<tcp::socket>& peer_socket) {
        // Обработка исключения при работе с клиентом
        // Закрытие соединения и другие действия по очистке ресурсов
        // ...
    }
};

class UserCredentialsManager {
public:
    bool login(const std::string& username, const std::string& password) {
        std::shared_lock<std::shared_mutex> lock(data_mutex_);
        if (user_credentials_.count(username) > 0 && user_credentials_[username] == sha256(password))
            return true;

        return false;
    }

    bool registerUser(const std::string& username, const std::string& password) {
        std::unique_lock<std::shared_mutex> lock(data_mutex_);
        if (user_credentials_.count(username) > 0)
            return false;

        user_credentials_[username] = sha256(password);
        return true;
    }

private:
    std::unordered_map<std::string, std::string> user_credentials_;
    std::shared_mutex data_mutex_;

    std::string sha256(const std::string& password) {
        unsigned char hash[SHA256_DIGEST_LENGTH];
        SHA256_CTX sha256;
        SHA256_Init(&sha256);
        SHA256_Update(&sha256, password.c_str(), password.length());
        SHA256_Final(hash, &sha256);

        std::stringstream ss;
        for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {
            ss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(hash[i]);
        }

        return ss.str();
    }
};

int main() {
    try {
        Server server;
        server.start();
    }
    catch (const std::exception& ex) {
        std::cerr << "Exception in main: " << ex.what() << std::endl;
    }

    return 0;
}
